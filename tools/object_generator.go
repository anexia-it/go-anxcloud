package main

import (
	"encoding/json"
	"flag"
	"fmt"
	"html/template"
	"io"
	"log"
	"os"
	"path"
	"path/filepath"
	"strings"

	"go/ast"
	"go/parser"
	"go/token"
)

const magicCommentPrefix = "// anxcloud:"

type typeDefinition struct {
	Name     string   `json:"name"`
	IsObject bool     `json:"isObject"`
	Hooks    []string `json:"hooks"`
	File     string   `json:"file"`
	Line     int      `json:"line"`
}

// objectGenerator parses a single file or package to produce a single output.
type ObjectGenerator struct {
	mode    string
	in      string
	outfile string

	out io.WriteCloser

	pkg string

	types []typeDefinition
}

func (gen *ObjectGenerator) run() {
	gen.types = make([]typeDefinition, 0)

	sources := make([]string, 0, 1)
	if stat, err := os.Stat(gen.in); err == nil {
		if stat.IsDir() {
			filepath.Walk(gen.in, func(entryPath string, info os.FileInfo, err error) error {
				if err != nil {
					log.Fatalf("Error reading source path \"%v\": %v", gen.in, err)
				}

				if path.Dir(entryPath) != gen.in {
					return nil
				}

				if !info.IsDir() && isGoFile(info.Name()) {
					sources = append(sources, entryPath)
				}
				return nil
			})
		} else {
			sources = append(sources, gen.in)
		}
	} else {
		log.Fatalf("Error reading source path \"%v\": %v", gen.in, err)
	}

	for _, s := range sources {
		gen.parseFile(s)
	}

	if len(gen.types) > 0 {
		out, err := os.OpenFile(gen.outfile, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0644)
		if err != nil {
			log.Printf("Error opening output file \"%v\": %v", gen.outfile, err)
		}

		gen.out = out
	} else {
		return
	}

	switch gen.mode {
	case "tests":
		gen.writeHeader()
		gen.generateTestCode()
	case "data":
		json.NewEncoder(gen.out).Encode(gen.types)
	default:
		log.Printf("Mode %v is not yet implemented", gen.mode)
	}
}

func (gen *ObjectGenerator) parseFile(in string) {
	fset := token.NewFileSet()
	file, err := parser.ParseFile(fset, in, nil, parser.ParseComments)
	if err != nil {
		log.Fatalf("Error opening file \"%v\": %v\n", in, err)
	}

	if gen.pkg == "" {
		gen.pkg = file.Name.Name
	} else if gen.pkg != file.Name.Name {
		log.Fatalf("Found multiple packages in package directory! First found: \"%v\", now found \"%v\" in file \"%v\"", gen.pkg, file.Name.Name, in)
	}

	gen.parseTypeComments(file, fset, in)
}

func (gen *ObjectGenerator) writeHeader() {
	if gen.mode == "docs" {
		fmt.Fprintf(gen.out, "// Code generated by github.com/anexia-it/go-anxcloud/tools object-generator - DO NOT EDIT!\n\n")
	}

	fmt.Fprintf(gen.out, "package %v\n", gen.pkg)

	if gen.mode == "tests" {
		fmt.Fprint(gen.out, `
import (
	. "github.com/anexia-it/go-anxcloud/pkg/utils/test/gomega"
	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"

	"github.com/anexia-it/go-anxcloud/pkg/api/types"
)
`)
	}
}

func (gen *ObjectGenerator) parseTypeComments(file *ast.File, fset *token.FileSet, source string) {
	if file.Decls == nil {
		return
	}

	if file.Comments == nil {
		return
	}

	type typeComment struct {
		pos      token.Pos
		line     int
		genDecl  *ast.GenDecl
		typeSpec *ast.TypeSpec
		comments []*ast.Comment
	}

	types := make([]*typeComment, 0, len(file.Decls))

	for _, d := range file.Decls {
		genDecl, ok := d.(*ast.GenDecl)
		if !ok || genDecl.Tok != token.TYPE {
			continue
		}

		pos := genDecl.Pos()

		if genDecl.Doc != nil {
			pos = genDecl.Doc.Pos()
		}

		for _, s := range genDecl.Specs {
			typeSpec := s.(*ast.TypeSpec)

			types = append(types, &typeComment{
				genDecl:  genDecl,
				typeSpec: typeSpec,
				pos:      pos,
				line:     fset.Position(pos).Line - 2,
			})
		}
	}

comments:
	for _, c := range file.Comments {
		line := fset.Position(c.End()).Line

		for _, t := range types {
			if line == t.line {
				if t.comments == nil {
					t.comments = make([]*ast.Comment, 0)
				}

				t.comments = append(t.comments, c.List...)
				t.line = fset.Position(c.Pos()).Line - 1
				continue comments
			}
		}
	}

	for _, t := range types {
		for _, c := range t.comments {
			if strings.HasPrefix(c.Text, magicCommentPrefix) {
				log.Printf("Found type to generate code for: %v (%v:%v)", t.typeSpec.Name, source, t.line+1)

				gen.processComment(strings.TrimPrefix(c.Text, magicCommentPrefix), t.genDecl, source, t.line+1)
			}
		}
	}
}

func (gen *ObjectGenerator) processComment(comment string, decl *ast.GenDecl, file string, line int) {
	parts := strings.Split(comment, ":")
	specs := make(map[string]string, len(parts))
	for _, part := range parts {
		kv := strings.Split(part, "=")

		v := ""
		if len(kv) == 2 {
			v = kv[1]
		}

		specs[kv[0]] = v
	}

	switch decl.Tok {
	case token.TYPE:
		for _, s := range decl.Specs {
			ts := s.(*ast.TypeSpec)

			_, isObject := specs["object"]

			var hooks []string
			if h, ok := specs["hooks"]; ok {
				hooks = strings.Split(h, ",")
			}

			gen.types = append(gen.types, typeDefinition{
				Name:     ts.Name.Name,
				IsObject: isObject,
				Hooks:    hooks,
				File:     file,
				Line:     line,
			})
		}
	}
}

func (gen *ObjectGenerator) generateTestCode() {
	const templates = `
{{ define "objectTest" }}
var _ = Describe("Object {{ .Name }}", func() {
	{{- range .Interfaces }}
	It("implements the interface {{ . }}", func() {
		var i {{ . }}
		o := {{ $.Name }}{}
		Expect(&o).To(ImplementInterface(&i))
	})
	{{- end }}
})
{{ end }}`

	t, err := template.New("templates").Parse(templates)
	if err != nil {
		log.Fatalf("Error parsing templates: %v", err)
	}

	for _, td := range gen.types {
		if !td.IsObject {
			continue
		}

		interfaces := []string{"types.Object"}

		for _, h := range td.Hooks {
			interfaces = append(interfaces, fmt.Sprintf("types.%v", h))
		}

		err := t.ExecuteTemplate(gen.out, "objectTest", map[string]interface{}{
			"Name":       td.Name,
			"Interfaces": interfaces,
		})
		if err != nil {
			log.Fatalf("Error executing template for object tests: %v", err)
		}
	}
}

func isGoFile(file string) bool {
	return strings.HasSuffix(file, ".go") && !strings.HasSuffix(file, "_test.go") && !strings.HasPrefix(file, ".")
}

var _ = func() interface{} {
	tools["object-generator"] = func() {
		in := flag.String("in", "", "path to file or package directory to process, if it ends with /..., every directory below the given (and including the given) will be processed, as long as they have *.go file inside")
		outfile := flag.String("out", "", "output file path, relative to the source path")
		mode := flag.String("mode", "tests", "code generator mode (tests)")
		flag.Parse()

		sources := make([]string, 0, 1)
		if strings.HasSuffix(*in, "/...") {
			sourcesAdded := make(map[string]interface{})

			filepath.Walk(path.Dir(*in), func(entryPath string, info os.FileInfo, err error) error {
				dir := path.Dir(entryPath)

				if err != nil {
					log.Fatalf("Error walking source directory: %v", err)
				}

				if isGoFile(info.Name()) {
					if _, ok := sourcesAdded[dir]; !ok {
						sources = append(sources, dir)
						sourcesAdded[dir] = nil
					}
				}

				return nil
			})
		} else {
			sources = append(sources, *in)
		}

		for _, s := range sources {
			sourceDir := s
			if stat, err := os.Stat(s); err == nil && !stat.IsDir() {
				sourceDir = path.Dir(s)
			} else if err != nil {
				log.Fatalf("Error reading source \"%v\": %v", s, err)
			}

			outfile := path.Join(sourceDir, *outfile)

			gen := ObjectGenerator{
				in:      s,
				outfile: outfile,
				mode:    *mode,
			}

			gen.run()
		}
	}

	return nil
}()
